// The MIT License (MIT)

// Copyright (c) 2017-2020 Uber Technologies Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package main

import (
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
)

// oddly there is no constant for this in the template package.
// without this, unrecognized {{.map_keys}} just insert "<no value>" rather than failing,
// which is a bit of a crazy default imo.
const missingMapKeysError = "missingkey=error"

func usage(cmd string) string {
	return strings.TrimPrefix(fmt.Sprintf(`
A very simple template-file executor for go:generate usage.

Usage: %s templatefile[.tmpl] [positional template args or] [-key value -template data] [-out filename.go]
At least one template argument or an output filename is required.

This template-runner is intentionally very simple, understands no types at all,
parses no code, and does not support nested structures / list vars / etc.
If you need something fancier you should probably try something more capable
instead, e.g. gowrap.

Arguments to the template may be positional or keyed or both.
Keyed arguments can be accessed with {{.key}}, positional with {{arg 0}},
and environment variables with {{env "key"}}.

If no output filename is specified, the first argument's value will become the
[source_filename]_[first_arg]_gen.go inferred filename.
E.g.:     %s thing -key SomeThing -other Data
Produces: source_file_some_thing_gen.go

The output file will automatically be prefixed with the command used to generate it,
as well as the current package name, so you do not need to specify them in your template.
Normal builds will ensure your file is formatted via goimports, so wrong indentation and
unused imports are safe to ignore in the template file.

Added funcs include:
	env "string": get an env var
		(e.g. 'env "GOPACKAGE"' will return the current package name)
	arg int: get a template-argument by index
		(e.g. for: '%s some.tmpl one two -key value three')
		(you get:  'arg 0' gets "one", 'arg 2' gets "three")
	snake "string": snake_case a string
	camel "string": CamelCase a string
`, cmd, cmd, cmd), "\n")
}

func prefix(args ...string) string {
	return strings.TrimPrefix(fmt.Sprintf(`
// Code generated by %s. DO NOT EDIT.
//
// go-generate command: %s
// in file: %s:%s

package %s

`,
		args[0],
		strings.Join(args, " "),
		// modify with t.Env if testing
		os.Getenv("GOFILE"), os.Getenv("GOLINE"),
		os.Getenv("GOPACKAGE")), "\n")
}

func main() {
	if len(os.Args) < 3 {
		_, _ = fmt.Fprintf(os.Stderr, usage(os.Args[0]))
		os.Exit(1)
	}
	// simple check to ensure go-generate env vars are in place
	if os.Getenv("GOFILE") == "" {
		log.Fatalf("should be run with go-generate, not by hand")
	}

	tmplFilename := os.Args[1]
	if !strings.HasSuffix(tmplFilename, ".tmpl") {
		tmplFilename = tmplFilename + ".tmpl"
	}

	keyed, positional, first, out, err := args(os.Args[2:]...)
	if err != nil {
		log.Fatal(err)
	}

	if first == "" && out == "" {
		log.Fatalf("no first value found and no explicit output filename, cannot infer output filename")
	}
	var outFilename string
	if out != "" {
		outFilename = out
	} else {
		// [source_file]_[first_arg]_gen.go
		outFilename = strings.Split(os.Getenv("GOFILE"), ".")[0] + "_" + snake(first) + "_gen.go"
	}

	dat, err := os.ReadFile(tmplFilename)
	if err != nil {
		log.Fatalf("cannot read template file %q: %v", tmplFilename, err)
	}

	t, err := template.New("").
		Funcs(map[string]any{
			"env":   func(key string) string { return os.Getenv(key) },
			"arg":   func(idx int) string { return positional[idx] },
			"snake": snake,
			"camel": camel,
		}).
		Option(missingMapKeysError).
		Parse(string(dat))
	if err != nil {
		log.Fatalf("cannot parse template file %q: %v", tmplFilename, err)
	}

	var wr strings.Builder
	err = t.Execute(&wr, keyed)
	if err != nil {
		log.Fatalf("template execution failed: %v", err)
	}

	f, err := os.OpenFile(outFilename, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		log.Fatalf("unable to open output file %q: %v", outFilename, err)
	}
	defer func() {
		err := f.Close()
		if err != nil {
			log.Fatalf("failed to close file %q: %v", outFilename, err)
		}
	}()

	_, err = f.WriteString(prefix(os.Args...))
	if err != nil {
		log.Fatalf("failed to write header to output file %q: %v", outFilename, err)
	}
	_, err = f.WriteString(wr.String())
	if err != nil {
		log.Fatalf("failed to write generated text to output file %q: %v", outFilename, err)
	}
}

// plucks out high level args from os.Args, excluding any leading ones that are intentionally ignored
// like the command name and the template filename.
func args(a ...string) (keyed map[string]string, positional []string, first string, outfile string, err error) {
	keyed = map[string]string{}
	key := "" // current key, if any

	for _, arg := range a {
		// "-" prefix means key/value, no exceptions.
		// if you want a "-" prefixed value to be allowed, don't accept it positionally.
		if key == "" && strings.HasPrefix(arg, "-") {
			key = arg[1:]
			continue
		}

		// "out" is special
		if key == "out" {
			outfile = arg
			key = ""
			continue
		}

		// had a key?  next value is its value.
		if key != "" {
			keyed[key] = arg
			key = ""
			if first == "" {
				first = arg
			}
			continue
		}
		// else it's just positional
		positional = append(positional, arg)
		if first == "" {
			first = arg
		}
	}

	if key != "" {
		err = fmt.Errorf("found key with no value: %q", key)
	}

	return
}

// converts "someString" to "some_string".
// already-lowercased strings should be unaffected.
func snake(s string) string {
	var out strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			l := unicode.ToLower(r)
			if i == 0 {
				out.WriteRune(l)
			} else {
				out.WriteRune('_')
				out.WriteRune(l)
			}
		} else {
			out.WriteRune(r)
		}
	}
	return out.String()
}

// converts "some_string" to "SomeString".
// already-camelcased strings should be unaffected.
func camel(s string) string {
	var out strings.Builder
	upperNext := false
	for i, r := range s {
		if i == 0 {
			out.WriteRune(unicode.ToUpper(r))
		} else if r == '_' {
			if upperNext {
				out.WriteRune(r) // retain sequential underscores: ___up -> __Up
			}
			upperNext = true
		} else if upperNext {
			out.WriteRune(unicode.ToUpper(r))
			upperNext = false
		} else {
			out.WriteRune(r)
		}
	}
	return out.String()
}
